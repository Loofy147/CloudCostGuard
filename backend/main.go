package main

import (
	"cloudcostguard/backend/database"
	"cloudcostguard/backend/estimator"
	"cloudcostguard/backend/pricing"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"sync"
	"time"

	_ "cloudcostguard/docs" // docs is generated by Swag CLI
	httpSwagger "github.com/swaggo/http-swagger"
)

var (
	pricingCache *pricing.PriceList
	cacheMutex   sync.RWMutex
)

// @title CloudCostGuard API
// @version 1.0
// @description This is the API for the CloudCostGuard backend service.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /
func main() {
	database.InitDB()
	startPricingService() // This will populate the DB in the background

	// Initial cache load
	fmt.Println("Performing initial load of pricing cache...")
	if err := refreshPricingCache(); err != nil {
		log.Printf("Warning: initial pricing cache load failed: %v. Will retry.", err)
	}

	// Start periodic cache refresh
	go func() {
		for {
			time.Sleep(6 * time.Hour)
			fmt.Println("Refreshing pricing cache...")
			if err := refreshPricingCache(); err != nil {
				log.Printf("Warning: periodic pricing cache refresh failed: %v", err)
			}
		}
	}()

	http.HandleFunc("/swagger/", httpSwagger.WrapHandler)
	http.HandleFunc("/estimate", estimateHandler)
	http.HandleFunc("/status", statusHandler)

	fmt.Println("Starting CloudCostGuard backend server on :8080...")
	if err := http.ListenAndServe(":8080", nil); err != nil {
		log.Fatalf("Failed to start server: %v", err)
	}
}

// statusHandler handles HTTP requests to the /status endpoint.
// @Summary Get pricing data staleness
// @Description Returns the timestamp of the oldest pricing data record in the database.
// @Produce  json
// @Success 200 {object} map[string]string
// @Failure 500 {string} string "Failed to query database"
// @Router /status [get]
func statusHandler(w http.ResponseWriter, r *http.Request) {
	var oldestTimestamp time.Time
	err := database.DB.QueryRow("SELECT MIN(last_updated) FROM aws_prices").Scan(&oldestTimestamp)
	if err != nil {
		http.Error(w, "Failed to query database", http.StatusInternalServerError)
		return
	}

	response := map[string]string{
		"oldest_pricing_data": oldestTimestamp.Format(time.RFC3339),
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(response); err != nil {
		http.Error(w, "Failed to encode response", http.StatusInternalServerError)
	}
}

// estimateHandler handles HTTP requests to the /estimate endpoint.
// @Summary Estimate Terraform plan cost
// @Description Parses a Terraform plan, estimates the cost, and returns the estimated monthly cost.
// @Accept  json
// @Produce  json
// @Param   body body estimator.EstimateRequest true "Request body"
// @Param   region query string false "AWS Region" default(us-east-1)
// @Success 200 {object} estimator.EstimationResponse
// @Failure 400 {string} string "Failed to parse request body or Terraform plan"
// @Failure 500 {string} string "Failed to estimate cost"
// @Failure 503 {string} string "Pricing data is not yet available"
// @Router /estimate [post]
func estimateHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Only POST method is allowed", http.StatusMethodNotAllowed)
		return
	}

	region := r.URL.Query().Get("region")
	if region == "" {
		region = "us-east-1"
	}

	var requestBody estimator.EstimateRequest
	if err := json.NewDecoder(r.Body).Decode(&requestBody); err != nil {
		http.Error(w, "Failed to parse request body", http.StatusBadRequest)
		return
	}

	plan := requestBody.Plan

	cacheMutex.RLock()
	currentPriceList := pricingCache
	cacheMutex.RUnlock()

	if currentPriceList == nil {
		http.Error(w, "Pricing data is not yet available. Please try again in a few minutes.", http.StatusServiceUnavailable)
		return
	}

	cost, err := estimator.Estimate(plan, currentPriceList, region, &requestBody.UsageEstimates)
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to estimate cost: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(cost); err != nil {
		http.Error(w, "Failed to encode response", http.StatusInternalServerError)
	}
}

func refreshPricingCache() error {
    rows, err := database.DB.Query("SELECT sku, product_json, terms_json FROM aws_prices")
    if err != nil {
        return err
    }
    defer rows.Close()

    newPriceList := pricing.NewPriceList()
    for rows.Next() {
        var sku string
        var productJSON, termsJSON []byte
        if err := rows.Scan(&sku, &productJSON, &termsJSON); err != nil {
            return err
        }

        var product pricing.Product
        if err := json.Unmarshal(productJSON, &product); err != nil {
			fmt.Printf("Warning: could not unmarshal product for SKU %s: %v\n", sku, err)
            continue
        }
        newPriceList.Products[sku] = product

        var terms map[string]pricing.Term
        if err := json.Unmarshal(termsJSON, &terms); err != nil {
			fmt.Printf("Warning: could not unmarshal terms for SKU %s: %v\n", sku, err)
            continue
        }
		newPriceList.Terms.OnDemand[sku] = terms
    }

	cacheMutex.Lock()
	pricingCache = newPriceList
	cacheMutex.Unlock()
	fmt.Println("Pricing cache refresh complete.")
    return nil
}
